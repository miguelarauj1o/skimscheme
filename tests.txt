-- 1 -> comment, if, eqv?, /, mod
-- OK
"(begin (comment LOL) (if (eqv? (/ 1 1) (mod 5 4)) '(OK)))"

-- 2 -> ifelse, eqv?, /, mod, cons
-- (0 1 2 3 4)
"(begin (if (eqv? (/ 3 1) (mod 5 4)) '(OK) (cons (mod 10 5) '(1 2 3 4))))"

-- 3 -> let, /, if, eqv?, set!, mod
-- 4
"(begin (let ((x (/ 4 2)) (y 3)) (if (eqv? x (mod 5 3)) (set! y (mod 10 6)) y)))"

-- 4 -> set!, lt?, mod, /
-- #t
"(begin (define x 10) (set! x 2) (lt? (mod x 1) (/ 1 1)))"

-- 5 -> recursion, lt?, /, mod
-- #f
"(begin (define fat (lambda (n) (if (eqv? n (/ (mod 5 4) 1)) 1 (* n (fat (- n 1)))))) (lt? (fat 5) 100))"

-- 6 -> let, mod, /
-- 
"(begin (define x 10) (let ((x (/50 10)) (y (* x (mod 7 5)))) (+ x y)))"

-- 7 -> let, set!, /, mod
-- 
(begin (let ((x (/ 45 9)) (y (mod 10 5))) (set! x (+ x (set! y (+ x x))))))

-- 8 -> if, eqv?, /, mod
-- 
"(begin (define fib (lambda (n) (if (eqv? n (/ 4 2)) 0 (if (eqv? n (mod 8 7)) 1 (+ (fib (- n 1)) (fib (- n 2))))))) (fib 4))"

-- 9 -> let, set!, cons, /, mod
-- 
"(begin (define x 5) (define y (/ 100 10)) (define res -1) (let ((x 8)) (begin (set! res 10) (let ((z 5) (y 21)) (begin (set! x (mod 7 4)) (set! y 12))) (set! y x))) (define lista (cons x (cons y (cons res '())))))"

-- 10 -> make-closure, let, set!, mod, /
-- 
"(begin (let ((i (mod 5 4))) (define f (make-closure (lambda (y) (begin (set! i (+ i y)) i))))) (define val1 (f 1)) (define val2 (f 2)) (/ val1 val2))"

-- 11 ->
--
""

-- 12 ->
--
""

-- 13 ->
--
""

-- 14 ->
--
""

-- 15 -> quicksort
""