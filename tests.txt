-- 1 -> comment, if, eqv?, /, mod
-- OK
"(begin (comment LOL) (if (eqv? (/ 1 1) (mod 5 4)) '(OK)))"

-- 2 -> ifelse, eqv?, /, mod, cons
-- (0 1 2 3 4)
"(begin (if (eqv? (/ 3 1) (mod 5 4)) '(OK) (cons (mod 10 5) '(1 2 3 4))))"

-- 3 -> let, /, if, eqv?, set!, mod
-- 4
"(begin (let ((x (/ 4 2)) (y 3)) (if (eqv? x (mod 5 3)) (set! y (mod 10 6)) y)))"

-- 4 -> set!, lt?, mod, /
-- #t
"(begin (define x 10) (set! x 2) (lt? (mod x 1) (/ 1 1)))"

-- 5 -> recursion, lt?, /, mod
-- #f
"(begin (define fat (lambda (n) (if (eqv? n (/ (mod 5 4) 1)) 1 (* n (fat (- n 1)))))) (lt? (fat 5) 100))"

-- 6 -> make-closure, let, set!, mod, /
-- 
"(begin (let ((i (mod 5 4))) (define f (make-closure (lambda (y) (begin (set! i (+ i y)) i))))) (define val1 (f 1)) (define val2 (f 2)) (/ val1 val2))"

-- 7 -> make-closure, let, set!, if, lt?, /, mod
--
"(begin (let ((i 2)) (define f (make-closure (lambda (y) (begin (set! i (+ i y)) i))))) (if (lt? (f (/ 239 12)) (f (mod 239 12))) 1 0))"

-- 8 -> make-closure, let, set!, eqv?, mod, /
--
"(begin (let ((i (mod 5 4)) (j (/ 16 4))) (define clo (make-closure (lambda (x y) (begin (set! x (+ i j)) (set! j (+ x y)) j))))) (define clo1 (clo 1 2)) (define clo2 (clo 1 2)) (eqv? clo1 clo2))" 

-- 9 -> make-closure, let, set!, mod
--
"(begin (let ((i (mod 5 4))) (define f (make-closure (lambda (y) (begin (set! i (+ i y)) i) )))) f)"

-- 10 -> quicksort
"(begin (define part (lambda (comp l) (if (eqv? l '()) '() (if (comp (car l)) (cons (car l) (part comp (cdr l))) (part comp (cdr l)))))) (define qsort (lambda (l) (if (eqv? l '()) '() (let ((p (car l))) (append (append (qsort (part (lambda (x) (lt? x p)) l)) (part (lambda (x) (eqv? x p)) l)) (qsort (part (lambda (x) (lt? p x)) l))))))) (qsort '(19 38 17 26 45 4 34 21 1 0 1 123)))